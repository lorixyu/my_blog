# 快速排序详解
## 基础代码模版
```cpp
void quickSort(int q[], int l, int r) {
    if (l >= r) return;

    int x = q[(l + r) >> 1], i = l - 1, j = r + 1;

    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quickSort(q, l, j);
    quickSort(q, j + 1, r);
}
```
**代码解释**

```
首先当区间内只有一个数或者没有数时return;
从数组中选一个基准数x，利用双指针法从数组两端遍历数组，保证i左边的数都小于x，j右边的数都大于x。内部两个while结束时代表i，j停在了大于和小于x的数的位置，则需要交换i，j，不过前提是i < j。
递归左右两边。
```
---
***针对快排该模版的细节分析***

**分析1**

用j做划分时，x不能取q[r]。

解释：x是q[r]，那么j会永远停在分区的最右侧，i会不断右移，当i==j时退出循环。此时如果``quickSort(q, l, j), quickSort(q, j + 1, r)``显然，[ l , j ]会死循环；[ j + 1 , r ]会越界。

同理，用i做划分时，x不能取q[l]。``quickSort(q, l, i - 1), quickSort(q, i, r)``。

**分析2**

``do i++; while(q[i] < x)``和``do j--; while(q[j] > x)`` 中不能用q[i] <= x 和 q[j] >= x。

当分区内所有数相同时，i会不断自增直到 i > r，此时q[i]就会越界。

**分析3**

``if (i < j) swap(q[i], q[j])``可不可以写成 ``(i <= j)``

***可以***

因为当两个指针指向同一个元素时，交不交换都一样。

**分析4**

``while (i < j)``可不可以写成``while (i <= j)``

***不可以***

当两个指针相等时它们仍会进行一次++与--操作，可能会因此越界

eg：Array[1,2]，当i==j==1时，会在执行一次++与--。就会越界。而快排是基于分治的，所以一定会越到这种情况。

**分析5**

``do-while``的好处

如果写成``while(q[i] < x) i++; while (q[j] > x) j--;``。当q[i]和q[j]都等于x时，i和j就卡住不更新了，会死循环。

**分析6**

不可以写成``if (l > r) return;``，这样写传达的意思是``l==r``时不return，此时就会继续向下执行，while也无法进入，不断进入递归函数，就会造成死递归。

## 基准数优化
```
快速排序在某些输入下的时间效率可能降低。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端（如果）元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组 最右端，导致左子数组长度为0、右子数组长度为n-1。
  - 如此递归下去，每轮哨兵划分后都有一个子数组的长度为0。
  - 分治策略失效，快速排序退化为“冒泡排序”的近似形式。
为了尽量避免这种情况发生，我们可以优化哨兵划分中的基准数的选取策略。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。

需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。

为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至O(n^2)的概率大大降低。
```
```cpp
/* 选取三个候选元素的中位数 */
int medianThree(int q[], int left, int mid, int right) {
    int l = q[left], m = q[mid], r = q[right];
    if ((l <= m && m <= r) || (r <= m && m <= l))
        return mid; // m 在 l 和 r 之间
    if ((m <= l && l <= r) || (r <= l && l <= m))
        return left; // l 在 m 和 r 之间
    return right;
}
```
## 递归深度优化
```
在某些输入下，快速排序可能占用空间较多。以完全有序的输入数组为例，设递归中的子数组长度为m，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 m-1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 n-1，此时需要占用 O(n) 大小的栈帧空间。

为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，仅对较短的子数组进行递归，对较长子数组用循环来处理————即不断把长数组变短。由于较短子数组的长度不会超过 n/2，因此这种方法能确保递归深度不超过 O(logn)，从而将最差空间复杂度优化至 O(logn)
```
```cpp
int partition(int q[], int l, int r) {
    int i = l - 1, j = r + 1;
    int x = q[(l + r) >> 1];
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    return j;
}

void quickSort(int q[], int l, int r) {
    while (l < r) {
        int pivot = partition(q, l, r);
        if (l - pivot < r - pivot) {
            quickSort(q, l, pivot);
            l = pivot + 1;
        } else {
            quickSort(q, pivot + 1, r);
            r = pivot;
        }
    }
}
```