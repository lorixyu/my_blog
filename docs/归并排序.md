# 归并排序详解
## 基础代码模版
```cpp
void merge_sort(int q[], int l, int r) {
    // 递归终止
    if (l >= r) return;
    // 分成子问题
    int mid = l + r >> 1;
    // 递归处理子问题
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1, k = 0;
    // 合并子问题
    while (i <= mid && j <= r) {
        if (q[i] <= q[j])
            tmp[k ++] = q[i ++];
        else
            tmp[k ++] = q[j ++];
    }
    
    while (i <= mid) tmp[k ++] = q[i ++];
    while (j <= r) tmp[k ++] = q[j ++];
    
    for (i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];
}
```
**代码解释**

```
首先当区间内没有数或者只有一个数时return。与快排不同的是，归并排序是先递归再处理。核心是合并部分，当有两个有序子数组时，分别用i,j指向两个子数组的头进行遍历，有序存入tmp数组中，直到i或j走到尽头，那时，再进行两个while循环，把未处理的元素放入tmp中，最后再从临时数组放回q数组。
```
***针对快排该模版的细节分析***

**边界分析**
为什么不用``mid - 1``作为边界，即``merge_sort(q, l, mid - 1), merge_sort(q, mid, r);``

因为``mid = l + r >> 1``是下取整，mid可能取到l，会造成无限划分。
解决方法就是改为``mid = l + r + 1 >> 1``。